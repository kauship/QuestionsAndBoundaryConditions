Merge intervals:

Solution:
import java.util.*;

public class MergeIntervals {

    public static List<int[]> merge(int[][] intervals) {
        List<int[]> merged = new ArrayList<>();
        if (intervals == null || intervals.length == 0) return merged;

        // Sort using Comparator: first by start, then by end (optional but robust)
        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0])
                                         .thenComparingInt(a -> a[1]));

        int[] current = intervals[0];

        for (int i = 1; i < intervals.length; i++) {
            int[] next = intervals[i];
            if (current[1] >= next[0]) {
                // Merge
                current[1] = Math.max(current[1], next[1]);
            } else {
                // No overlap, add current to result and move to next
                merged.add(current);
                current = next;
            }
        }
        merged.add(current); // Add the final interval

        return merged;
    }

    public static void printIntervals(List<int[]> result) {
        for (int[] interval : result) {
            System.out.print("[" + interval[0] + ", " + interval[1] + "] ");
        }
        System.out.println();
    }

    // You can run and test all hard test cases here
    public static void main(String[] args) {
        List<int[][]> testCases = List.of(
            new int[][]{{1, 2}, {2, 3}, {3, 4}},                      // Touching intervals
            new int[][]{{1, 10}, {2, 5}, {6, 8}},                     // Contained
            new int[][]{{5, 6}, {1, 3}, {2, 4}},                      // Unsorted
            new int[][]{{-10, -5}, {-6, 0}, {1, 3}, {2, 4}},          // Negative + positive
            new int[][]{{1, 1}, {1, 2}, {2, 2}},                      // Single-point
            new int[][]{{1, 2}, {10, 12}, {15, 20}},                  // Disjoint
            new int[][]{{1, 5}, {2, 6}, {3, 7}, {4, 8}},              // All overlapping
            new int[][]{},                                           // Empty
            new int[][]{{1, 2}},                                      // Single interval
            new int[][]{{Integer.MIN_VALUE, 0}, {0, Integer.MAX_VALUE}}, // Edge integer values
            new int[][]{{1, 4}, {1, 5}, {1, 3}}                       // Same start
        );

        for (int i = 0; i < testCases.size(); i++) {
            System.out.print("Test case " + (i + 1) + ": ");
            List<int[]> result = merge(testCases.get(i));
            printIntervals(result);
        }
    }
}



#	Test Case Description	Input Intervals	Expected Merged Output	Edge Case Being Tested
1	Touching but not overlapping	[[1, 2], [2, 3], [3, 4]]	[[1, 4]]	Merging intervals that touch at boundaries
2	Fully contained intervals	[[1, 10], [2, 5], [6, 8]]	[[1, 10]]	Nested intervals within a larger interval
3	Unsorted input	[[5, 6], [1, 3], [2, 4]]	[[1, 4], [5, 6]]	Sorting required before merging
4	Negative and positive values	[[-10, -5], [-6, 0], [1, 3], [2, 4]]	[[-10, 0], [1, 4]]	Handles negative numbers and mixed sign intervals
5	Single-point intervals	[[1, 1], [1, 2], [2, 2]]	[[1, 2]]	Correctly merging intervals where start == end
6	Disjoint intervals with large gaps	[[1, 2], [10, 12], [15, 20]]	[[1, 2], [10, 12], [15, 20]]	No false merges between widely spaced intervals
7	All intervals overlapping	[[1, 5], [2, 6], [3, 7], [4, 8]]	[[1, 8]]	Multiple overlapping intervals merge into one
8	Empty input	[]	[]	Boundary case with no intervals
9	Single interval	[[1, 2]]	[[1, 2]]	Boundary case with only one interval
10	Integer overflow edge	[[Integer.MIN_VALUE, 0], [0, Integer.MAX_VALUE]]	[[Integer.MIN_VALUE, Integer.MAX_VALUE]]	Correct handling at integer limits
11	Same start, different ends	[[1, 4], [1, 5], [1, 3]]	[[1, 5]]	Start same, different end boundaries
